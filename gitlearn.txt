//创建版本库
1.cd git    //定位到指定路径
2.git init  //新建版本库
//版本分支提交
3.git add .  git add readme.txt //工作区存到暂存区
4.git commit -m "提交备注"      //暂存区所有文件提交到仓库
5.git status //查看当前仓库状态
6.git diff readme.txt //查看文件修改内容
7.git log //仓库修改日志
8.git reflog //查看所有操作日志
//版本回退
9.git reset --hard HEAD^ //回退到上一个版本 --  git reset --hard HEAD^^ //上上个版本  -- git reset --hard HEEAD~100  //回退到上100个版本
10.git reset --hard 版本号 //回退到指定版本
11.git cat readme.txt //查看文件内容
//撤销修改
12.git checkout --readme.txt  //工作区撤销到上一步
13.git reset HEAD readme.txt  //暂存区文件回退到工作区  如果提交到版本库了，可以回退到上个版本（如9）
//删除文件
14. rm readme.txt  //删除文件或直接找到文件删除  注：commit后版本库中已删除，否则可以恢复删除的文件到最新版本，但最近提交的一次修改会丢失（9）
//远程仓库
15. ssh-keygen -t rsa -C "your email address"  //创建SHH并保存，登录github，setting中add shh key拷贝id_rsa.pub中所有内容到key栏，添加完成
16. git remote add origin git@github.com:github帐户名/本地仓库名.git  //github上新建版本库，把本地已有版本库与之关联
17. git push -u origin master //本地版本库推送到远程库上，初次推送加-u 以后不用
18. github ssh第一次推送时，会确认本地key是否添加到github信任列表中了，yes即可
19. git clone 远程库地址  //克隆远程库到本地，有多种协议除原生ssh外还有http（速度慢，每次推送输入口令）
//分支管理
20. git checkout -b dev //创建并切换到改分支
21. git branch dev //创建分支
22. git checkout dev //切换分支
23. git branch //查看所有分支 *为当前分支
24. git merge dev //合并指定分支到当前分支
25. git branch -d dev //删除分支  git branch -D feature  //强行删除分支feature
//解决冲突 多个分支提交同一个文件修改，合并时发生冲突，不能快速合并
//会提示CONFLICT，修改提示的各个分支中的部分，再提交    当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。
26.$ git log --graph --pretty=oneline --abbrev-commit //查看冲突合并情况 删除一个分支即可
//分支策略1
27. git merge --no-ff -m "merge with no-ff" dev //合并dev分支到当前分支，禁用fast forwad
28.  git log --graphy --pretty=oneline --abbrev-commit //查看分支合并日志
//在实际开发中，我们应该按照几个基本原则进行分支管理：
//首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；
//那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；
//你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。
//bug解决
29 git stash  //储存当前分支工作现场
$ git checkout master //切换到修改bug的分支
Switched to branch 'master'
Your branch is ahead of 'origin/master' by 6 commits.
$ git checkout -b issue-101  //创建bug分支，进行修改
Switched to a new branch 'issue-101'
//修改bug，提交 
$ git add readme.txt 
$ git commit -m "fix bug 101"
[issue-101 cc17032] fix bug 101
 1 file changed, 1 insertion(+), 1 deletion(-)
//切换回分支mastrer 合并到master，删除bug分支 提交
 $ git checkout master
Switched to branch 'master'
Your branch is ahead of 'origin/master' by 2 commits.
$ git merge --no-ff -m "merged bug fix 101" issue-101
Merge made by the 'recursive' strategy.
 readme.txt |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
$ git branch -d issue-101
Deleted branch issue-101 (was cc17032).
//切换回原来工作的分支
$ git checkout dev
Switched to branch 'dev'
$ git status
# On branch dev
nothing to commit (working directory clean)
=======
//分支策略1
//工作区是干净的，刚才的工作现场存到哪去了？用git stash list命令看看：
$ git stash list
stash@{0}: WIP on dev: 6224937 add merge
//工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：
//一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；
//另一种方式是用git stash pop，恢复的同时把stash内容也删了：
$ git stash pop
# On branch dev
# Changes to be committed:
#   (use "git reset HEAD <file>..." to unstage)
#
#       new file:   hello.py
#
# Changes not staged for commit:
#   (use "git add <file>..." to update what will be committed)
#   (use "git checkout -- <file>..." to discard changes in working directory)
#
#       modified:   readme.txt
#
Dropped refs/stash@{0} (f624f8e5f082f2df2bed8a4e09c12fd2943bdd40)
//再用git stash list查看，就看不到任何stash内容了：
$ git stash list
//你可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令：
$ git stash apply stash@{0}


